#include <Wire.h>
#include <Adafruit_PWMServoDriver.h>

// Endereço padrão do PCA9685
#define PCA9685_ADDR 0x40

// Frequência para servos
#define SERVO_FREQ 50  // 50 Hz

// Limites típicos de servo (ajusta depois!)
#define SERVO_MIN  150  // pulso mínimo
#define SERVO_MAX  600  // pulso máximo
#define posmin 40
#define posmax 140

#define zerope 40
#define umpe 120
#define doispe 55
#define trespe 90
#define quatrope 65
#define cincope 65
#define oitope 25
#define novepe 115
#define dezpe 50
#define onzepe 80
#define dozepe 60
#define trezepe 90

#define STEPS_FOR_180 24  // número de "gait cycles" para ~180°

int pos;
Adafruit_PWMServoDriver pwm = Adafruit_PWMServoDriver(PCA9685_ADDR);

//Classe máquina de estados vinda do código do display do trabalho 1
typedef struct {
  int state;
  unsigned long tes;   // time entering state
  unsigned long tis;   // time in state
} fsm_t;

fsm_t fsm;

//Estados fsm
enum {
  Aranha_deitada = 0,           // estado inicial
  Aranha_a_levantar,            // executa Levanta_Aranha()
  Aranha_em_pe,                 // estado estável
  Aranha_a_deitar,              // executa Deita_Aranha()
  Aranha_a_andar,               // Executa Walk()
  Aranha_velocidade_levantar,   // estado para escolher velocidade da rotina Levanta_Aranha()
  Aranha_velocidade_deitar,      // estado para escolher velocidade da rotina Deita_Aranha()
  Aranha_velocidade_andar,       // estado para escolher velocidade da rotina Walk()
  
  
  
  Aranha_velocidade_virar_esq,
  Aranha_velocidade_virar_dir,
  Aranha_a_virar_esq,
  Aranha_a_virar_dir

};

// Forward declaration
void moveServo(uint8_t channel, uint8_t angle);
void Levanta_Aranha(int velocidade);
void Deita_Aranha(int velocidade);
void WalkStep(int velocidade);


void fsm_update();
void set_state(fsm_t &fsm, int new_state);


void WalkStepDir(int velocidade, int dir_esq, int dir_dir); // (mantive assinatura caso queiras usar depois)
void Turn180Blocking(int velocidade, int direction); // direction: -1 = left, +1 = right


// Bloco para utilizarmos o Serial para transição de estados
char cmd = 0;
int speed_l = 1;
int speed_d = 1;
int speed_w = 1;
int speed_turn= 1;

void read_serial() {
  if (Serial.available()) {
    cmd = Serial.read();

    //talvez entre
  } else {
    cmd = 0;
  }
}
//

void setup() {
  Serial.begin(115200);
  delay(1000);
  set_state(fsm, Aranha_em_pe);

  Serial.println("Inicializando PCA9685...");

  // Iniciar I2C
  Wire.setSDA(20);
  Wire.setSCL(21);
  Wire.begin();  // GP4 = SDA, GP5 = SCL

  // Iniciar PCA9685
  pwm.begin();
  pwm.setPWMFreq(SERVO_FREQ);
  delay(10);

  Serial.println("PCA9685 pronto!");
  Serial.println("Movendo servo para posição central...");

  // Teste: mover servo do canal 0 para posição central
  pos=0;
  moveServo(0,zerope);     // CALIBRADA EM PÉ -> 45      Levantada para mover -> 90
  moveServo(1,umpe);       // CALIBRADA EM PÉ -> 120     
  moveServo(2,doispe);        // CALIBRADA EM PÉ -> 55      Levantada para mover -> 100
  moveServo(3,trespe);        // CALIBRADA EM PÉ -> 90      
  moveServo(4,quatrope);        // CALIBRADA EM PÉ -> 65      Levantada para mover -> 110
  moveServo(5,cincope);        // CALIBRADA EM PÉ -> 65      
  //moveServo(6,90);
  //moveServo(7,90);
  moveServo(8,oitope);        // CALIBRADA EM PÉ -> 25      Levantada para mover -> 70
  moveServo(9,novepe);       // CALIBRADA EM PÉ -> 115     
  moveServo(10,dezpe);       // CALIBRADA EM PÉ -> 50      Levantada para mover -> 95
  moveServo(11,onzepe);       // CALIBRADA EM PÉ -> 80      
  moveServo(12,dozepe);        // CALIBRADA EM PÉ -> 60      Levantada para mover -> 75
  moveServo(13,trezepe);       // CALIBRADA EM PÉ -> 90      
  //moveServo(14,90); 
  moveServo(15,90);
  delay(3000);
}

void loop() {

  read_serial();
  fsm_update();
}





// Função para mover servo por ângulo (0–180)
void moveServo(uint8_t channel, uint8_t angle) {
  angle = constrain(angle, 0, 180);
  
  uint16_t pulse = map(angle, 0, 180, SERVO_MIN, SERVO_MAX);
  pwm.setPWM(channel, 0, pulse);

  /*
  Serial.print("Servo ");
  Serial.print(channel);
  Serial.print(" -> ");
  Serial.print(angle);
  Serial.println(" graus");
  */
}

void Levanta_Aranha(int velocidade){
  int delay_number, incremento;
  if (velocidade == 1){
    delay_number=50;
    incremento = 1;
  }
  if (velocidade == 2){
    delay_number = 25;
    incremento = 2;
  }
  if (velocidade == 3){
    delay_number = 25;
    incremento = 5;
  }

  for (pos=0; pos<=50; pos=pos+incremento){
    moveServo(0,zerope+50-pos);
    moveServo(2,doispe+50-pos);
    moveServo(4,quatrope+50-pos);
    moveServo(8,oitope+50-pos);
    moveServo(10,dezpe+50-pos);
    moveServo(12,dozepe+50-pos);
    delay(delay_number);
  }
}

void Deita_Aranha(int velocidade){
  int delay_number, incremento;
  if (velocidade == 1){
    delay_number=50;
    incremento = 1;
  }
  if (velocidade == 2){
    delay_number = 25;
    incremento = 2;
  }
  if (velocidade == 3){
    delay_number = 25;
    incremento = 5;
  }
  for (pos=0; pos<=50; pos=pos+incremento){
    moveServo(0,zerope+pos);
    moveServo(2,doispe+pos);
    moveServo(4,quatrope+pos);
    moveServo(8,oitope+pos);
    moveServo(10,dezpe+pos);
    moveServo(12,dozepe+pos);
    delay(delay_number);
  }

}
//Função que faz robô andar
void WalkStep(int velocidade) {

  static int fase = 0;     // 0..5 (A) | 6..11 (B)
  static int pos = 0;
  static unsigned long lastTime = 0;

  int delay_servos, incremento, pos_patas, pos_ombros;

  if (velocidade == 1) {
    delay_servos = 15;
    incremento   = 1;
    pos_patas    = 30;
    pos_ombros   = 30;
  } else {
    delay_servos = 12;
    incremento   = 2;
    pos_patas    = 30;
    pos_ombros   = 25;
  }

  if (cmd == 's') {
    fase = 0;
    pos = 0;
    set_state(fsm, Aranha_em_pe);
    return;
  }

  if (millis() - lastTime < delay_servos) return;
  lastTime = millis();

  switch (fase) {

    // ===== WALK A =====
    case 0: // sobem A/mexem B
      moveServo(0, zerope + pos);
      moveServo(4, quatrope + pos);
      moveServo(10, dezpe + pos);
      moveServo(3, trespe - pos);
      moveServo(9, novepe + pos);
      moveServo(13, trezepe + pos);

      
      pos += incremento;
      if (pos >= pos_ombros) { pos = 0; fase++; }
      break;

    case 1: // mexem A1
      moveServo(1, umpe - pos);
      moveServo(5, cincope - pos);
      moveServo(11, onzepe + pos);
      pos += incremento;
      if (pos >= pos_patas) { pos = 0; fase++; }
      break;

    case 2: // descem A
      moveServo(0, zerope + pos_ombros - pos);
      moveServo(4, quatrope + pos_ombros - pos);
      moveServo(10, dezpe + pos_ombros - pos);
      pos += incremento;
      if (pos >= pos_ombros) { pos = 0; fase++; }
      break;

    case 3: // sobem B
      moveServo(2, doispe + pos);
      moveServo(8, oitope + pos);
      moveServo(12, dozepe + pos);
      pos += incremento;
      if (pos >= pos_ombros) { pos = 0; fase++; }
      break;

    case 4: // andam A1
      moveServo(1, umpe - pos_patas + pos);
      moveServo(5, cincope - pos_patas + pos);
      moveServo(11, onzepe + pos_patas - pos);
      pos += incremento;
      if (pos >= pos_patas) { pos = 0; fase++; }
      break;

    // ===== WALK B =====
    case 5: // mexem B1
      moveServo(3, trespe - pos);
      moveServo(9, novepe + pos);
      moveServo(13, trezepe + pos);
      pos += incremento;
      if (pos >= pos_patas) { pos = 0; fase++; }
      break;

    case 6: // descem B
      moveServo(2, doispe + pos_ombros - pos);
      moveServo(8, oitope + pos_ombros - pos);
      moveServo(12, dozepe + pos_ombros - pos);
      pos += incremento;
      if (pos >= pos_ombros) { pos = 0; fase++; }
      break;

    case 7: // sobem A
      moveServo(0, zerope + pos);
      moveServo(4, quatrope + pos);
      moveServo(10, dezpe + pos);
      pos += incremento;
      if (pos >= pos_ombros) { pos = 0; fase++; }
      break;

    case 8: // andam B1
      moveServo(3, trespe - pos_patas + pos);
      moveServo(9, novepe + pos_patas - pos);
      moveServo(13, trezepe + pos_patas - pos);
      pos += incremento;
      if (pos >= pos_patas) { pos = 0; fase++; }
      break;
      default:
      fase = 0;
      if (pos >= pos_ombros) { 
        pos = 0;}
      break;
  }
}

void Turn180Blocking(int velocidade, int direction) {
  int delay_servos, incremento, pos_patas, pos_ombros;
  if (velocidade == 1) {
    delay_servos = 15;
    incremento = 1;
    pos_patas = 30;
    pos_ombros = 30;
  } else if (velocidade == 2) {
    delay_servos = 12;
    incremento = 2;
    pos_patas = 30;
    pos_ombros = 25;
  } else { // velocidade 3
    delay_servos = 10;
    incremento = 3;
    pos_patas = 30;
    pos_ombros = 20;
  }

  Serial.print("Iniciando viragem ");
  Serial.print(direction == -1 ? "esquerda" : "direita");
  Serial.print(" com velocidade ");
  Serial.println(velocidade);

  // ciclos de gait — cada ciclo executa uma sequência completa (A->B)
  for (int cycle = 0; cycle < STEPS_FOR_180; cycle++) {

    // --- Fase 0: levantar ombros A / mexer B ombros (com direção aplicada) ---
    for (int p = 0; p <= pos_ombros; p += incremento) {
      // ombros A sobem (mantêm mesma direção)
      moveServo(0, zerope + p);
      moveServo(4, quatrope + p);
      moveServo(10, dezpe + p);
      // ombros B ajustam com sinal para gerar rotação
      moveServo(3, trespe + direction * p);
      moveServo(9, novepe + direction * p);
      moveServo(13, trezepe + direction * p);
      delay(delay_servos);
    }

    // --- Fase 1: mexem patas A (pos_patas) com direção aplicada (forward/back) ---
    for (int p = 0; p <= pos_patas; p += incremento) {
      // patas A: 1,5,11  -> movimento aplicado com sinal invertido para facer forward/back
      moveServo(1, umpe - direction * p);
      moveServo(5, cincope - direction * p);
      moveServo(11, onzepe + direction * p);
      delay(delay_servos);
    }

    // --- Fase 2: descer ombros A ---
    for (int p = 0; p <= pos_ombros; p += incremento) {
      moveServo(0, zerope + pos_ombros - p);
      moveServo(4, quatrope + pos_ombros - p);
      moveServo(10, dezpe + pos_ombros - p);
      delay(delay_servos);
    }

    // --- Fase 3: levantar ombros B / mexer A ombros (com sinal oposto) ---
    for (int p = 0; p <= pos_ombros; p += incremento) {
      moveServo(2, doispe + p);
      moveServo(8, oitope + p);
      moveServo(12, dozepe + p);
      // ajustar também os ombros A para trabalharem contra-rotação se necessário
      moveServo(0, zerope + p);
      moveServo(4, quatrope + p);
      moveServo(10, dezpe + p);
      delay(delay_servos);
    }

    // --- Fase 4: andam A1 (invertendo mãos para rotação) ---
    for (int p = 0; p <= pos_patas; p += incremento) {
      // patas A entram novamente
      moveServo(1, umpe - direction * (pos_patas - p));
      moveServo(5, cincope - direction * (pos_patas - p));
      moveServo(11, onzepe + direction * (pos_patas - p));
      delay(delay_servos);
    }

    // --- Fase 5: mexem B1 (para completar a sequência) ---
    for (int p = 0; p <= pos_patas; p += incremento) {
      moveServo(3, trespe + direction * p);
      moveServo(9, novepe + direction * p);
      moveServo(13, trezepe + direction * p);
      delay(delay_servos);
    }

    // --- Fase 6: descem B ombros ---
    for (int p = 0; p <= pos_ombros; p += incremento) {
      moveServo(2, doispe + pos_ombros - p);
      moveServo(8, oitope + pos_ombros - p);
      moveServo(12, dozepe + pos_ombros - p);
      delay(delay_servos);
    }

    // --- Fase 7: return to neutral shoulders A (pequeno passo) ---
    for (int p = 0; p <= pos_ombros; p += incremento) {
      moveServo(0, zerope + p);
      moveServo(4, quatrope + p);
      moveServo(10, dezpe + p);
      delay(delay_servos);
    }

    // opcional: checar se o utilizador pediu stop imediato
    if (Serial.available()) {
      char c = Serial.read();
      if (c == 's') {
        Serial.println("Viragem interrompida por 's'.");
        cmd = 0;
        set_state(fsm, Aranha_em_pe);
        return;
      }
    }
  } // fim ciclos

  Serial.println("Viragem ~180deg concluída (ajusta STEPS_FOR_180 se necessário).");
  // volta para em pé
  set_state(fsm, Aranha_em_pe);
}





// Função que chama set_state e cumpre a lógica da máquina de estaddos com transições a utilizar o serial monitor
void fsm_update() {
  fsm.tis = millis() - fsm.tes;

  switch (fsm.state) {

    case Aranha_deitada:
      if (cmd == 'l') {     // l no serial monitor faz com que a aranha levante
        set_state(fsm,Aranha_velocidade_levantar);
        Serial.println("Escolha a velocidade para levantar entre 1 e 3.");
        //set_state(fsm, Aranha_a_levantar);
      }
      break;

    case Aranha_velocidade_levantar:
      if (cmd != 0) {
        if (cmd == '1' || cmd == '2' || cmd == '3') {
          speed_l = cmd - '0';    // se fizessemos simplesmente (int)cmd , o valor não seria 1, por causa da conversão hexadecimal!
          set_state(fsm,Aranha_a_levantar);
        }
        else {
          Serial.println("Velocidade inválida!Escolha uma velocidade entre 1 e 3.");
        }
      }
      break;

    case Aranha_a_levantar:
      Levanta_Aranha(speed_l);
      speed_l=1;
      set_state(fsm, Aranha_em_pe);
      break;

    case Aranha_velocidade_deitar:
      if (cmd != 0) {
        if (cmd == '1' || cmd == '2' || cmd == '3') {
          speed_d = cmd - '0';    // se fizessemos simplesmente (int)cmd , o valor não seria 1, por causa da conversão hexadecimal!
          set_state(fsm,Aranha_a_deitar);
        }
        else {
          Serial.println("Velocidade inválida!Escolha uma velocidade entre 1 e 3.");
        }
      }
      break;

    case Aranha_velocidade_andar:
      if (cmd != 0) {
        if (cmd == '1' || cmd == '2' || cmd == '3') {
          speed_w = cmd - '0';    // se fizessemos simplesmente (int)cmd , o valor não seria 1, por causa da conversão hexadecimal!
          set_state(fsm,Aranha_a_andar);
          Serial.println("Para parar o robô, utilize a tecla 's'.");
        }
        else {
          Serial.println("Velocidade inválida!Escolha uma velocidade entre 1 e 3.");
        }
      }
      break;

    case Aranha_em_pe:
      if (cmd == 'd') {     // d no serial monitor faz com que a aranha deite
        set_state(fsm, Aranha_velocidade_deitar);
        Serial.println("Escolha a velocidade para levantar entre 1 e 3.");
      }
      if (cmd == 'w') {     // w no serial monitor faz com que a aranha ande
        set_state(fsm,Aranha_velocidade_andar);
        Serial.println("Escolha a velocidade para andar entre 1 e 3.");
      }
      if (cmd == 'q') { // q = virar esquerda
      set_state(fsm, Aranha_velocidade_virar_esq);
      Serial.println("Escolha velocidade para virar esquerda (1-3).");
      }
      if (cmd == 'e') { // e = virar direita
      set_state(fsm, Aranha_velocidade_virar_dir);
      Serial.println("Escolha velocidade para virar direita (1-3).");
      }
      break;
    
    case Aranha_a_deitar:
      Deita_Aranha(speed_d);
      speed_d=1;
      set_state(fsm, Aranha_deitada);
      break;

    case Aranha_a_andar:
    if (cmd == 's') {
      set_state(fsm,Aranha_em_pe);
      Serial.println("Aranha em pé. Comandos disponíveis:");
      Serial.println("Andar - 'w'");
      Serial.println("Deitar - 'd'");
    }
    else {
      WalkStep(speed_w);
    } 
      break;
        case Aranha_velocidade_virar_esq:
      if (cmd != 0) {
        if (cmd == '1' || cmd == '2' || cmd == '3') {
          speed_turn = cmd - '0';
          set_state(fsm, Aranha_a_virar_esq);
          cmd = 0;
        } else {
          Serial.println("Velocidade inválida!Escolha 1, 2 ou 3.");
          cmd = 0;
        }
      }
      break;
          case Aranha_a_virar_esq:
      // direction = -1 para esquerda
      Turn180Blocking(speed_turn, -1);
      speed_turn = 1;
      // Turn180Blocking já faz set_state para Aranha_em_pe no fim
      break;

    // escolher velocidade para virar direita
    case Aranha_velocidade_virar_dir:
      if (cmd != 0) {
        if (cmd == '1' || cmd == '2' || cmd == '3') {
          speed_turn = cmd - '0';
          set_state(fsm, Aranha_a_virar_dir);
          cmd = 0;
        } else {
          Serial.println("Velocidade inválida!Escolha 1, 2 ou 3.");
          cmd = 0;
        }
      }
      break;

    // executar viragem direita (bloqueante)
    case Aranha_a_virar_dir:
      // direction = +1 para direita
      Turn180Blocking(speed_turn, +1);
      speed_turn = 1;
      // Turn180Blocking já faz set_state para Aranha_em_pe no fim
      break;


  }
}

//função para transição de estados
void set_state(fsm_t &fsm, int new_state) {
  if (fsm.state != new_state) {
    fsm.state = new_state;
    fsm.tes = millis();
    fsm.tis = 0;
  }
}

